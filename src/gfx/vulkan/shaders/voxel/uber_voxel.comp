#version 460
#extension GL_EXT_scalar_block_layout : require

#include <intersectables/cube.glsl>
#include <intersectables/sphere.glsl>
#include <ray.glsl>
#include <voxel.glsl>

layout(local_size_x = 32, local_size_y = 32) in;

const uint VoxelBrick_EdgeLength = 8;
struct VoxelBrick
{
    Voxel[VoxelBrick_EdgeLength][VoxelBrick_EdgeLength]
         [VoxelBrick_EdgeLength] voxels;
};
IntersectionResult
VoxelBrick_tryIntersect(vec3 center, const uint edgeLength, const Ray ray);
IntersectionResult
VoxelBrick_tryIntersect(uint offset, vec3 brickCorner, const Ray ray);

layout(set = 0, binding = 0, rgba8_snorm) writeonly
    restrict uniform image2D out_image;
layout(set = 0, binding = 1, std430) readonly restrict uniform WorldInfo
{
    mat4 inv_model_view_proj;
    mat4 model_view_proj;

    vec3  camera_position;
    float _pad0;

    vec3  sphere_center;
    float _pad1;

    float sphere_radius;
}
in_world_info;
layout(set = 0, binding = 2, std430) readonly restrict buffer Voxels
{
    VoxelBrick[] brick;
}
in_voxels;

vec4 calculatePixelColor(const Ray ray);

void main()
{
    const ivec2 pixel_xy   = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 image_size = imageSize(out_image);

    const vec2 inter_pixel_delta = vec2(1.0, 1.0) / vec2(image_size)
                                 - /* for clarity */
                                   vec2(0.0, 0.0) / vec2(image_size);

    const vec2 normalized_pixel_xy = (vec2(pixel_xy) / vec2(image_size)) * 2.0
                                   - 1.0 + (inter_pixel_delta / 2);

    const float nearPlaneDistance = 0.1;
    const float farPlaneDistance  = 100000.0;

    const vec4 nearScreenSpace =
        vec4(normalized_pixel_xy, nearPlaneDistance, 1.0);
    const vec4 farScreenSpace =
        vec4(normalized_pixel_xy, farPlaneDistance, 1.0);

    vec4 nearPoint = in_world_info.inv_model_view_proj * nearScreenSpace;
    nearPoint /= nearPoint.w;

    vec4 farPoint = in_world_info.inv_model_view_proj * farScreenSpace;
    farPoint /= farPoint.w;

    Ray ray;
    ray.origin    = in_world_info.camera_position;
    ray.direction = normalize(farPoint.xyz - nearPoint.xyz);

    // we invert the ray's direction as a resukt of how screenspace coordinates
    // work in vulkan., -1, -1 actually is positive in our cooridnate system
    ray.direction = -ray.direction;

    imageStore(out_image, pixel_xy, calculatePixelColor(ray));
}

vec4 calculatePixelColor(const Ray ray)
{
    IntersectionResult bestIntersection;
    bestIntersection.intersection_occurred = false;

    propagateIntersection(
        bestIntersection, VoxelBrick_tryIntersect(0, vec3(0, 0, 0), ray));

    {
        Cube cube;
        cube.center      = in_world_info.sphere_center;
        cube.edge_length = in_world_info.sphere_radius;

        propagateIntersection(bestIntersection, Cube_tryIntersect(cube, ray));
    }

    {
        Sphere sphere;
        sphere.center = in_world_info.sphere_center + vec3(0, 10.0, 0);
        sphere.radius = in_world_info.sphere_radius;

        propagateIntersection(
            bestIntersection, Sphere_tryIntersect(sphere, ray));
    }

    if (bestIntersection.intersection_occurred)
    {
        return vec4(bestIntersection.maybe_normal / 2 + 0.5, 1.0);
    }
    else
    {
        const vec4 RayMissColor = vec4(0.0, 0.0, 0.0, 0.0);
        return RayMissColor;
    }
}

IntersectionResult
VoxelBrick_tryIntersect(uint offset, vec3 brickCorner, const Ray ray)
{
    const float VoxelBrick_EdgeLength = 8.0;

    // Calculate the voxel brick position
    vec3 brickPos =
        brickCorner
        + vec3(float(offset % 8), float((offset / 8) % 8), float(offset / 64));

    vec3 X      = brickPos;
    vec3 step   = sign(ray.direction);
    vec3 tDelta = abs(1.0 / ray.direction);
    vec3 tMax   = tDelta * 0.5;

    for (int i = 0; i < 100; i++)
    { // Adjust the number of iterations as needed
        if (tMax.x < tMax.y)
        {
            if (tMax.x < tMax.z)
            {
                X.x += step.x;
                if (X.x < brickCorner.x
                    || X.x >= brickCorner.x + VoxelBrick_EdgeLength)
                {
                    return IntersectionResult_getMiss();
                }
                tMax.x += tDelta.x;
            }
            else
            {
                X.z += step.z;
                if (X.z < brickCorner.z
                    || X.z >= brickCorner.z + VoxelBrick_EdgeLength)
                {
                    return IntersectionResult_getMiss();
                }
                tMax.z += tDelta.z;
            }
        }
        else
        {
            if (tMax.y < tMax.z)
            {
                X.y += step.y;
                if (X.y < brickCorner.y
                    || X.y >= brickCorner.y + VoxelBrick_EdgeLength)
                {
                    return IntersectionResult_getMiss();
                }
                tMax.y += tDelta.y;
            }
            else
            {
                X.z += step.z;
                if (X.z < brickCorner.z
                    || X.z >= brickCorner.z + VoxelBrick_EdgeLength)
                {
                    return IntersectionResult_getMiss();
                }
                tMax.z += tDelta.z;
            }
        }

        // Check intersection with the voxel at X
        Cube voxelCube;
        voxelCube.center      = X + 0.5;
        voxelCube.edge_length = 1.0;

        IntersectionResult result = Cube_tryIntersect(voxelCube, ray);
        if (result.intersection_occurred)
        {
            return result;
        }
    }

    return IntersectionResult_getMiss();
}
IntersectionResult
VoxelBrick_tryIntersect(vec3 center, const uint edgeLength, const Ray ray)
{
    const uint outerBoundSize = edgeLength;

    uint fEdgeLength = uint(VoxelBrick_EdgeLength);

    // Calculate the voxel brick position
    vec3 brickPos = center
                  + vec3(
                        float(1 % fEdgeLength),
                        float((1 / fEdgeLength) % fEdgeLength),
                        float(1 / (fEdgeLength * fEdgeLength)));

    vec3 X      = brickPos;
    vec3 step   = sign(ray.direction) * outerBoundSize;
    vec3 tDelta = abs(1.0 / ray.direction);
    vec3 tMax   = tDelta * 0.5;

    for (int i = 0; i < 100; i++)
    { // Adjust the number of iterations as needed
        if (tMax.x < tMax.y)
        {
            if (tMax.x < tMax.z)
            {
                X.x += step.x;
                if (X.x == center.x)
                {
                    return IntersectionResult_getMiss();
                }
                tMax.x += tDelta.x;
            }
            else
            {
                X.z += step.z;
                if (X.z == center.z)
                {
                    return IntersectionResult_getMiss();
                }
                tMax.z += tDelta.z;
            }
        }
        else
        {
            if (tMax.y < tMax.z)
            {
                X.y += step.y;
                if (X.y == center.y)
                {
                    return IntersectionResult_getMiss();
                }
                tMax.y += tDelta.y;
            }
            else
            {
                X.z += step.z;
                if (X.z == center.z)
                {
                    return IntersectionResult_getMiss();
                }
                tMax.z += tDelta.z;
            }
        }

        // Check intersection with the voxel at X
        Cube voxelCube;
        voxelCube.center      = X + 0.5;
        voxelCube.edge_length = 1.0;

        IntersectionResult result = Cube_tryIntersect(voxelCube, ray);
        if (result.intersection_occurred)
        {
            return result;
        }
    }

    return IntersectionResult_getMiss();
}