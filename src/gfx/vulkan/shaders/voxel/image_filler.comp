#version 460
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : enable

#include <../include/ray.glsl>
#include <../include/voxel.glsl>

layout(local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 0, rgba8_snorm) writeonly uniform image2D out_image;
layout(set = 0, binding = 1, std430) readonly uniform WorldBuffer
{
    vec3 camera_position;
    vec3 camera_forward;
    vec3 sphere_center;
    float _padd;
    float sphere_radius;
    float focal_length;
} in_world;

mat3 constructViewMatrix(vec3 forward, vec3 up) {
    vec3 right = cross(up, forward);
    up = cross(forward, right);
    return mat3(right, up, -forward);
}

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 image_size = imageSize(out_image);

    // Calculate the ray direction from the camera
    vec2 screen_coords = (vec2(pixel_coords) / vec2(image_size)) * 2.0 - 1.0;
    vec3 camera_forward = normalize(in_world.camera_forward);
    vec3 camera_up = vec3(0.0, 1.0, 0.0); // Assuming an "up" direction of (0,1,0)
    mat3 view_matrix = constructViewMatrix(camera_forward, camera_up);
    vec3 ray_direction = normalize(view_matrix * vec3(screen_coords, in_world.focal_length));

    // Calculate the transformed ray origin
    vec3 ray_origin = in_world.camera_position;

    // Check for sphere-ray intersection
    vec3 to_sphere = ray_origin - in_world.sphere_center;
    float a = dot(ray_direction, ray_direction);
    float b = 2.0 * dot(to_sphere, ray_direction);
    float c = dot(to_sphere, to_sphere) - (in_world.sphere_radius * in_world.sphere_radius);
    float discriminant = b * b - 4.0 * a * c;

    // If there is an intersection, color the pixel
    if (discriminant > 0.0) {
        // Calculate intersection point
        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);
        vec3 intersection_point = ray_origin + t1 * ray_direction;

        // Calculate pixel color for the sphere (e.g., blue)
        // vec3 sphere_color = vec3(0.0, 0.0, 1.0);
        vec3 normal = normalize(intersection_point - in_world.sphere_center);
        vec4 color = vec4(normal * 0.5 + 0.5, 1.0); // Color based on the surface normal

        // Write the color to the output image
        imageStore(out_image, pixel_coords, color);
    } else {
        // If there's no intersection, set the pixel color to the background color (e.g., black)
        imageStore(out_image, pixel_coords, vec4(0.0, 0.0, 0.0, 0.0));
    }
}
