#version 460
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : enable

#include <../include/ray.glsl>
#include <../include/voxel.glsl>

layout(local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 0, rgba8_snorm) writeonly uniform image2D out_image;
layout(set = 0, binding = 1, std430) readonly uniform WorldBuffer
{
    vec3 camera_position;
    vec3 camera_forward;
    vec3 sphere_center;
    float _padd;
    float sphere_radius;
    float focal_length;
} in_world;

vec4 calculateColor(in Ray ray)
{
    // Define the unit sphere at Xthe origin (radius = 1.0)
    // vec3 sphereCenter = vec3(0.0, 0.0, 1.0);
    // float sphereRadius = 0.5;

    // Compute the coefficients for the quadratic equation of the ray-sphere intersection
    vec3 oc = ray.origin - in_world.sphere_center;
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(oc, ray.direction);
    float c = dot(oc, oc) - in_world.sphere_radius * in_world.sphere_radius;

    // Calculate the discriminant to determine if there's an intersection
    float discriminant = b * b - 4.0 * a * c;

    if (discriminant > 0.0) {
        // Ray intersects the sphere
        // Calculate the value of t for the two possible intersection points
        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);
        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);

        // Choose the smaller positive t value
        float t = min(t1, t2);

        // Calculate the intersection point
        vec3 intersectionPoint = Ray_at(ray, t);

        // Calculate and return the color based on the intersection point
        vec3 normal = normalize(intersectionPoint - in_world.sphere_center);
        vec4 color = vec4(normal * 0.5 + 0.5, 1.0); // Color based on the surface normal
        return color;
    }

    // pallet in the background
    vec2 uuid = vec2(gl_GlobalInvocationID.xy);
    uuid /= vec2(imageSize(out_image).xy);
    return vec4(0.0, uuid, 1.0);
    // return vec4(0.0, 0.0, 0.0, 0.0);
}



mat3 constructViewMatrix(vec3 forward, vec3 up)
{
    vec3 right = cross(up, forward);
    up = cross(forward, right);
    return mat3(right, up, -forward);
}

void main()
{
    ivec2 this_pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 image_size = imageSize(out_image);

    // Calculate the ray direction from the camera
    vec2 screen_coords = (vec2(this_pixel_coords) / vec2(image_size)) * 2.0 - 1.0;
    vec3 camera_forward = normalize(in_world.camera_forward);
    vec3 camera_up = vec3(0.0, 1.0, 0.0); // Assuming an "up" direction of (0,1,0)
    mat3 view_matrix = constructViewMatrix(camera_forward, camera_up);

    Ray ray;
    ray.origin = in_world.camera_position;
    ray.direction = normalize(view_matrix * vec3(screen_coords, in_world.focal_length));

    imageStore(
        out_image,
        this_pixel_coords,
        calculateColor(ray)
    );
}
