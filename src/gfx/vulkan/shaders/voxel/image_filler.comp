#version 460
#extension GL_EXT_scalar_block_layout : require

#include <util.glsl>

layout(local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 0, rgba8) writeonly uniform image2D out_image;
layout(set = 0, binding = 1, std430) readonly uniform World
{
    vec3 camera_position;
    vec3 camera_forward;
    vec3 sphere_center;
    float sphere_radius;
    float focal_length;
} in_world;
struct Ray
{
    vec3 origin;
    vec3 direction;
};

vec3 Ray_at(in Ray self, in float t)
{
    return self.origin + self.direction * t;
}


vec4 calculateColor(in Ray ray)
{
    // Define the unit sphere at the origin (radius = 1.0)
    vec3 sphereCenter = vec3(0.0, 0.0, 1.0);
    float sphereRadius = 0.5;

    // Compute the coefficients for the quadratic equation of the ray-sphere intersection
    vec3 oc = ray.origin - in_world.sphere_center;
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(oc, ray.direction);
    float c = dot(oc, oc) - sphereRadius * sphereRadius;

    // Calculate the discriminant to determine if there's an intersection
    float discriminant = b * b - 4.0 * a * c;

    if (discriminant > 0.0) {
        // Ray intersects the sphere
        // Calculate the value of t for the two possible intersection points
        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);
        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);

        // Choose the smaller positive t value
        float t = min(t1, t2);

        // Calculate the intersection point
        vec3 intersectionPoint = Ray_at(ray, t);

        // Calculate and return the color based on the intersection point
        vec3 normal = normalize(intersectionPoint - in_world.sphere_center);
        vec4 color = vec4(normal * 0.5 + 0.5, 1.0); // Color based on the surface normal
        return color;
    }


    // pallet in the background
    // vec2 uuid = vec2(gl_GlobalInvocationID.xy);
    // uuid /= vec2(imageSize(out_image).xy);
    // return vec4(0.0, uuid, 1.0);
    return vec4(0.0, 0.0, 0.0, 0.0);

}


void main()
{
    const uint outImageWidth = imageSize(out_image).x;
    const uint outImageHeight = imageSize(out_image).y;

    if (gl_GlobalInvocationID.x > outImageWidth ||
        gl_GlobalInvocationID.y > outImageHeight)
    {
        return;
    }

    const float aspectRatio = 1.0;
    const float focalLength = 1.0;
    const float viewportWidth = 1.0;
    const float viewportHeight = aspectRatio * viewportWidth;

    const vec3 viewportU = vec3(viewportWidth, 0.0, 0.0);
    const vec3 viewportV = vec3(0.0, -viewportHeight, 0.0);

    const vec3 pixelDeltaU = viewportU / float(outImageWidth);
    const vec3 pixelDeltaV = viewportV / float(outImageHeight);

    const vec3 viewportUpperLeft = 
        in_world.camera_position -
        vec3(0.0, 0.0, focalLength) -
        viewportU / 2 -
        viewportV / 2;

    const vec3 pixel00Location =
        viewportUpperLeft + (pixelDeltaU + pixelDeltaV) * 0.5;


    const vec3 pixelCenter =
        pixel00Location + (pixelDeltaU * float(gl_GlobalInvocationID.x))
                            + (pixelDeltaV * float(gl_GlobalInvocationID.y));
    
    const vec3 rayDirection = pixelCenter - in_world.camera_position;

    Ray ray;
    ray.origin = in_world.camera_position;
    ray.direction = rayDirection;

    imageStore(
        out_image,
        ivec2(gl_GlobalInvocationID),
        convertLinearColorToSRGB(calculateColor(ray))
    );
}