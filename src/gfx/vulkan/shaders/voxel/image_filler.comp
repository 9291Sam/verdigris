#version 460
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : enable

#include <../include/ray.glsl>
#include <../include/voxel.glsl>

layout(local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 0, rgba8_snorm) writeonly uniform image2D out_image;
layout(set = 0, binding = 1, std430) readonly uniform World
{
    vec3 camera_position;
    vec3 camera_forward;
    vec3 sphere_center;
    float _padd;
    float sphere_radius;
    float focal_length;
} in_world;

vec4 calculateColor(in Ray ray)
{
    // Define the unit sphere at the origin (radius = 1.0)
    // vec3 sphereCenter = vec3(0.0, 0.0, 1.0);
    // float sphereRadius = 0.5;

    // Compute the coefficients for the quadratic equation of the ray-sphere intersection
    vec3 oc = ray.origin - in_world.sphere_center;
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(oc, ray.direction);
    float c = dot(oc, oc) - in_world.sphere_radius * in_world.sphere_radius;

    // Calculate the discriminant to determine if there's an intersection
    float discriminant = b * b - 4.0 * a * c;

    if (discriminant > 0.0) {
        // Ray intersects the sphere
        // Calculate the value of t for the two possible intersection points
        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);
        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);

        // Choose the smaller positive t value
        float t = min(t1, t2);

        // Calculate the intersection point
        vec3 intersectionPoint = Ray_at(ray, t);

        // Calculate and return the color based on the intersection point
        vec3 normal = normalize(intersectionPoint - in_world.sphere_center);
        vec4 color = vec4(normal * 0.5 + 0.5, 1.0); // Color based on the surface normal
        return color;
    }

    // pallet in the background
    vec2 uuid = vec2(gl_GlobalInvocationID.xy);
    uuid /= vec2(imageSize(out_image).xy);
    return vec4(0.0, uuid, 1.0);
    // return vec4(0.0, 0.0, 0.0, 0.0);
}

void main()
{
    const uint outImageWidth = imageSize(out_image).x;
    const uint outImageHeight = imageSize(out_image).y;

    const uint8_t a = uint8_t(4);

    if (gl_GlobalInvocationID.x > outImageWidth ||
            gl_GlobalInvocationID.y > outImageHeight)
    {
        return;
    }

    const float aspectRatio = float(uint8_t(1)); // 1.0;
    // const float in_world.focal_length = 1.0;
    const float viewportWidth = 1.0;
    const float viewportHeight = aspectRatio * viewportWidth;

    const vec3 viewportU = vec3(viewportWidth, 0.0, 0.0);
    const vec3 viewportV = vec3(0.0, -viewportHeight, 0.0);

    const vec3 pixelDeltaU = viewportU / float(outImageWidth);
    const vec3 pixelDeltaV = viewportV / float(outImageHeight);

    // const vec3 viewportUpperLeft =
    //     in_world.camera_position -
    //         vec3(0.0, 0.0, in_world.focal_length) -
    //         viewportU / 2 -
    //         viewportV / 2;
    const vec3 viewportUpperLeft =
    in_world.camera_position -
        in_world.camera_forward * vec3(0.0, 0.0, in_world.focal_length) -
        viewportU / 2 -
        viewportV / 2;

    const vec3 pixel00Location =
        viewportUpperLeft + (pixelDeltaU + pixelDeltaV) * 0.5;

    const vec3 pixelCenter =
        pixel00Location + (pixelDeltaU * float(gl_GlobalInvocationID.x))
            + (pixelDeltaV * float(gl_GlobalInvocationID.y));

    const vec3 rayDirection = pixelCenter - in_world.camera_position;

    // Modify the camera's orientation based on the in_world.camera_forward vector
mat3 cameraRotationMatrix = mat3(
    normalize(cross(in_world.camera_forward, vec3(0.0, 1.0, 0.0))),  // Right vector
    vec3(0.0, 1.0, 0.0),                                     // Up vector
    -normalize(in_world.camera_forward)                               // Forward vector
);

// Apply the camera's orientation to the ray direction
vec3 rotatedRayDirection = cameraRotationMatrix * rayDirection;

// Use rotatedRayDirection to construct your ray
Ray ray;
ray.origin = in_world.camera_position;
ray.direction = rotatedRayDirection;

    // Ray ray;
    // ray.origin = in_world.camera_position;
    // ray.direction = rayDirection;

    imageStore(
        out_image,
        ivec2(gl_GlobalInvocationID),
        calculateColor(ray)
    );
}
